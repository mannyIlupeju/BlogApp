{"version":3,"sources":["authPost.js"],"names":["User","require","bcrypt","registerValidation","loginValidation","req","res","_registerValidation","error","salt","hashedPassword","user","regeneratorRuntime","async","_context","prev","next","body","abrupt","status","send","details","message","awrap","findOne","email","sent","registerPost","genSalt","hash","password","name","save","t0","stop","loginPost","_loginValidation","token","_context2","emailExist","compare","jwt","sign","_id","process","env","TOKEN_SECRET","module","exports"],"mappings":"aACA,IAAMA,KAAOC,QAAQ,kBAAfD,IAAOC,QAAQ,gBAEfC,OAASD,QAAQ,qBADaA,QAAA,iBAA3BE,4BAAAA,mBAAWC,yBAAAA,gBACdF,aAAiB,SAAAG,EAAvBC,GAAuB,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAE,MAAA,KAAA,EAAA,GAAAT,EAMLJ,mBAAmBE,EAAIY,MAAhCT,EANcD,EAMdC,MANc,OAAAM,EAAAI,OAAA,SACuBjB,EAAQkB,OAAA,KAAAC,KAMdZ,EAAMa,QAAQ,GAAGC,UAPlCR,EAAAE,KAAA,EAAA,MAAA,KAAA,EAAA,OAAAF,EAAAE,KAAA,EAAAJ,mBAAAW,MAUIvB,KAAKwB,QAAQ,CAACC,MAAOpB,EAAIY,KAAKQ,SAVlC,KAAA,EAAA,OAAAX,EAAAY,MAILpB,EAAGa,OAAfQ,KAAAA,KAAAA,wBAJiBb,EAAAE,KAAA,EAAAJ,mBAAAW,MAIFrB,OAAA0B,QAAA,KAJE,KAAA,EAAA,OAIFnB,EAJEK,EAAAY,KAAAZ,EAAAE,KAAA,GAAAJ,mBAAAW,MAIFrB,OAAA2B,KAAAxB,EAAAY,KAAAa,SAAArB,IAJE,KAAA,GAAA,OAIFC,EAJEI,EAAAY,KAIFf,EAAA,IAAAX,KAAA,CAgBjB+B,KAAM1B,EAAIY,KAAKc,KAhBEN,MAAApB,EAGhBG,KAHgBiB,MAAAK,SAAApB,IAJEI,EAAAC,KAAA,GAAAD,EAAAE,KAAA,GAAAJ,mBAAAW,MAIFZ,EAAAqB,QAJE,KAAA,GAAAlB,EAAAY,KAAAZ,EAAAE,KAAA,GAAA,MAAA,KAAA,GAAAF,EAAAC,KAAA,GAAAD,EAAAmB,GAAAnB,EAAA,MAAA,IAIFR,EAAAa,OAAA,KAAAC,KAAAN,EAAAmB,IAJE,KAAA,GAAA,IAAA,MAAA,OAAAnB,EAAAoB,SAAA,KAAA,KAAA,CAAA,CAAA,GAAA,OAIFC,UAAA,SAAA9B,EAAAC,GAAA,IAAA8B,EAAA5B,EAAAG,EAAA0B,EAAA,OAAAzB,mBAAAC,MAAA,SAAAyB,GAAA,OAAA,OAAAA,EAAAvB,KAAAuB,EAAAtB,MAAA,KAAA,EAAA,GAAAoB,EAMbG,gBANalC,EAAAY,MAMbsB,EANaH,EAMbG,MANa,OAAAD,EAAApB,OAAA,SAOfqB,EAAJpB,OAAoBA,KAAJC,KAAAZ,EAAqBa,QAAA,GAAAC,UAPlBgB,EAAAtB,KAAA,EAAA,MAAA,KAAA,EAAA,OAAAsB,EAAAtB,KAAA,EAAAJ,mBAAAW,MAAAvB,KAAAwB,QAAA,CAAAC,MAUAvB,EAAAA,KAAO0B,SAVP,KAAA,EAAA,GAAAjB,EAAA2B,EAAAZ,KAAA,CAAAY,EAAAtB,KAAA,EAAA,MAAA,OAAAsB,EAAApB,OAAA,SAoCDZ,EAAIa,OAAO,KAAKC,KAAK,uBApCpB,KAAA,EAAA,OAAAkB,EAAAtB,KAAA,GAAAJ,mBAAAW,MAAArB,OAAAsC,QAWUtC,EAAAA,KAAO2B,SAASZ,EAAKa,WAX/B,KAAA,GAAA,GAAAQ,EAAAZ,KAAA,CAAAY,EAAAtB,KAAA,GAAA,MAAA,OAAAsB,EAAApB,OAAA,SAyCIZ,EAAIa,OAAO,KAAKC,KAAK,iBAzCzB,KAAA,GAebT,EAfa8B,IAeNC,KAAA,CAASC,IAAAhC,EAAAgC,KAAAC,QAAAC,IAAAC,cAEpBrB,EAAAA,OAAAA,gBAAgBA,GAFIL,KAAA,CAAAiB,MAAAA,IAfH,KAAA,GAAA,IAAA,MAAA,OAAAC,EAAAJ,WAAAa,OAAAC,QAAA,CAAArB,aAAAA,aAAAQ,UAAAA","file":"authPost.min.js","sourcesContent":["\nconst User = require('../models/auth')\nconst jwt = require('jsonwebtoken') //for login verification\nconst bcrypt = require('bcryptjs') //we use this to protect the password \nconst {registerValidation, loginValidation} = require('../validation')\n\n\nconst registerPost = async (req,res)=>{\n  //Validate data before we add a user \n  const {error} = registerValidation(req.body)\n  if(error) return res.status(400).send(error.details[0].message)\n\n  //check if user is in database\n  const emailExist = await User.findOne({email: req.body.email})\n  if (emailExist) res.status(400).send('Email already exists')\n\n  //Hash the password - We must protect password from being visible when we save it\n  const salt = await bcrypt.genSalt(10) //the complexity of the string that will get generated to protect our password\n  const hashedPassword = await bcrypt.hash(req.body.password, salt)\n\n  \n  // To Create a new user\n  const user = new User({\n    name: req.body.name,\n    email: req.body.email,\n    password: hashedPassword\n  });\n\n  try {\n    const savedUser = await user.save()\n    \n  } catch(err) {\n    res.status(400).send(err)\n  }\n}\n\n\nconst loginPost = async (req,res)=>{\n   const {error} = loginValidation(req.body)\n   if(error) return res.status(400).send(error.details[0].message)\n\n   //CHECK IF USER EXISTS\n   const user = await User.findOne({email: req.body.email})\n   if(!user) return res.status(400).send(\"Email is not found\") \n   \n\n   //CHECK IF PASSWORD IS CORRECT\n   const validPass = await bcrypt.compare(req.body.password, user.password) \n   if(!validPass) return res.status(400).send('Login failed')\n   \n  //Create and assign a token\n  //it takes the ID to know the user is logged in and a secret token\n  const token = jwt.sign({_id: user._id}, process.env.TOKEN_SECRET); \n\n  res.header('Authorization', token).send({token})\n\n  \n\n}\n\n\nmodule.exports = {registerPost, loginPost}"]}